<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《MySQL必知必会》学习笔记]]></title>
    <url>%2Fblog%2F2017%2F07%2F30%2F%E3%80%8Amysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[《MySQL必知必会》是MySQL入门书籍，本文是阅读该书的一些学习笔记，主要记录相关知识要点。 第三章 使用MySQLmsql -u username -p -h myserver -P port //连接数据库 USE database_name //打开数据库 SHOW DATABASES //显示可用数据库列表 SHOW TABLES //返回数据库中数据表的列表 SHOW COLUMNS FROM table_name //显示表中字段信息 自动增量的定义 第四章 检索数据SELECT field_name FROM table_name; //从表中检索选定的列 SELECT field_name1，field_name2 FROM table_name; //从表中检索多列 SELECT * FROM table_name; //检索表中所有列 SELECT DISTINCT field_name FROM table_name; //从表中检索选定的列(消除重复行) SELECT field_name FROM table_name LIMIT lines; //返回检索结果的前几行 SELECT field_name FROM table_name LIMIT strat_pos,lines; //返回检索结果中，从第strat_pos行开始的lines行 SELECT products.prod_name FROM crashcourse.products; //使用完全限定的表名(功能与第一个用法相同) 第五章 排序检索数据SELECT prod_name FROM products ORDER BY prod_id; //对prod_name列，以prod_id的字母顺序排列数据 SELECT prod_id,prod_price,prod_name FROM products ORDER BY prod_prices,prod_name; //通过多列数据对结果排序（首先依据prod_prices排序， //prod_prices相同时，再依据prod_name排序） SELECT prod_id,prod_price,prod_name FROM products ORDER BY prod_prices DESC,prod_name; //以prod_prices降序，prod_name升序排列数据，mysql默认升序排列， //如果想同时以prod_name降序排列，需要在prod_name后也加上DESC, //因为DESC关键字只应用到直接位于其前面的列名上。 SELECT prod_price FROM products ORDER BY prod_prices DESC LIMIT 1； //找出一个列中最高的值 Tips： 1.mysql默认升序排列数据2.DESC关键字只应用到直接位于其前面的列名上，根据多列降序，则每列都要加上DESC关键字3.ORDER BY子句必须是SELECT语句中的最后一条子句（一个子句通常由一个关键字和所提供的数据组成，FROM products是子句，ORDER BY prod_prices也是子句，但DESC和LIMIT 1不是子句）。 第六章 过滤数据SELECT prod_name,prod_price FROM products WHERE prod_name=&apos;fuses&apos;; //返回prod_name的值为Fuses的一行。 SELECT prod_name,prod_price FROM products WHERE prod_price&lt;=10; //列出价格小于或等于10美元的所有产品 SELECT prod_name,prod_price FROM products WHERE prod_price BETWEEN 5 AND 10; //检索价格在5美元和10美元之间的所有产品(包括5和10) SELECT cust_id FROM customers WHERE cust_email IS NULL; //返回没有email的顾客id Tips： 1.mysql的where子句支持的操作符有=，!=,&lt;,&lt;=,&gt;,&gt;=,BETWEEN2.未知具有特殊的含义，数据库不知道它们是否匹配，所以在匹配过滤或不匹配过滤时都不返回它们。 第七章 数据过滤SELECT prod_id,prod_price,prod_name FROM products WHERE vend_id=1003 AND prod_price &lt;=10; //检索由供应商1003制造且价格小于等于10美元的所有产品 SELECT prod_name,prod_price FROM products WHERE vend_id=1002 OR vend_id=1003; //检索供应商1002和1003制造的所有产品 SELECT prod_name,prod_price FROM products WHERE (vend_id=1002 OR vend_id=1003) AND prod_price&gt;=10; //检索价格为10美元（含）以上且由1002或1003制造的所有产品 //SQL在处理OR操作符前，优先处理AND操作符，所以上面的括号不能少， //否则将得不到想要的结果 SELECT prod_name,prod_price,vend_id FROM products WHERE vend_id IN(1002,1003) ORDER BY prod_name; //检索供应商1002和1003制造的所有产品 SELECT prod_name,prod_price FROM products WHERE vend_id NOT IN(1002,1003) ORDER BY prod_name; //检索1002和1003之外供应商制造的所有产品 Tips： 1.SQL在处理OR操作符前，优先处理AND操作符，使用()控制优先级2.IN操作符完成与OR相同的功能，但IN操作执行更快，而且IN中还可以包含其他SELECT语句，使得能够更动态地建立WHERE子句3.WHERE子句中的NOT操作符有且只有一个功能，那就是否定它之后所跟的任何条件4.MySQL仅支持使用NOT对IN、BETWEEN和EXISTS子句取反。 第八章 用通配符进行过滤SELECT prod_id,prod_name FROM products WHERE prod_name LIKE &apos;%anvil%&apos;; //匹配任何包含文本anvil的值 SELECT prod_id,prod_name FROM products WHERE prod_name LIKE &apos;_ ton anvil&apos;; //_只能匹配一个字符 Tips： 1.为在搜索子句中使用通配符，必须使用LIKE操作符；2.通配符%可以匹配0个、1个或多个字符，但不能匹配NULL；3.通配符_总是匹配一个字符，不能多也不能少；4.不要过度使用通配符，通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长；5.把通配符置于搜索模式的开始处，搜索起来是最慢的。 第九章 用正则表达式进行搜索SELECT prod_name FROM products WHERE prod_name LIKE &apos;1000&apos; ORDER BY prod_name; //匹配完整串1000 SELECT prod_name FROM products WHERE prod_name REGEXP &apos;1000&apos; ORDER BY prod_name; //匹配子串1000 SELECT prod_name FROM products WHERE prod_name REGEXP &apos;.000&apos; ORDER BY prod_name; //.匹配任意一个字符 SELECT prod_name FROM products WHERE prod_name REGEXP &apos;1000|2000&apos; ORDER BY prod_name; // |为正则表达式的OR操作符,它表示匹配其中之一， // 因此1000和2000都匹配并返回 SELECT prod_name FROM products WHERE prod_name REGEXP &apos;[123] Ton&apos;; //匹配几个字符之一 SELECT prod_name FROM products WHERE prod_name REGEXP &apos;[^123] Ton&apos;; //匹配123以外的几个字符之一 SELECT prod_name FROM products WHERE prod_name REGEXP &apos;[1-5] Ton&apos;; //匹配范围，常见范围：[1-9],[a-z]，[a-zA-Z0-9] SELECT prod_name FROM products WHERE prod_name REGEXP &apos;\\([0-9] sticks?\\)&apos;; // 双斜杠\\为转义字符，sticks?匹配stick和sticks SELECT prod_name FROM products WHERE prod_name REGEXP &apos;[[:digit:]]{4}&apos;; // 匹配连在一起的任意4位数字 // [:digit:]代表数字集合，{4}要求它前面的字符出现4次 SELECT prod_name FROM products WHERE prod_name REGEXP &apos;^[0-9\\.]&apos;; //找出以数字或小数点开始的所有prod_name // Tips： 1.LIKE和REGEXP的不同在于，LIKE匹配整个串而REGEXP匹配子串；2.MySQL中的正则表达式匹配（自版本3.23.4后）不区分大小写（即，大写和小写都匹配）。为区分大小写，可使用BINARY关键字，如WHERE prod_name REGEXP BINARY ‘JetPack .000’;3.^有两种用法。在集合中（用[和]定义），用它来否定该集合，否则，用来指串的开始处。 第十章 创建计算字段mysql&gt; SELECT Concat(RTrim(vend_name),&apos;(&apos;,RTrim(vend_country),&apos;)&apos;) -&gt; AS vend_title -&gt; From vendors -&gt; ORDER BY vend_name; +------------------------+ | vend_title | +------------------------+ | ACME(USA) | | Anvils R Us(USA) | | Furball Inc.(USA) | | Jet Set(England) | | Jouets Et Ours(France) | | LT Supplies(USA) | +------------------------+ //拼接字段并使用别名 mysql&gt; SELECT prod_id,quantity,item_price, -&gt; quantity*item_price AS expanded_price -&gt; FROM orderitems -&gt; Where order_num = 20005; +---------+----------+------------+----------------+ | prod_id | quantity | item_price | expanded_price | +---------+----------+------------+----------------+ | ANV01 | 10 | 5.99 | 59.90 | | ANV02 |3 | 9.99 | 29.97 | | TNT2|5 | 10.00 | 50.00 | | FB |1 | 10.00 | 10.00 | +---------+----------+------------+----------------+ //执行计算字段 Tips： 1.Concat()函数用于拼接多个字段；2.RTrim()函数去掉串右边的空格，LTrim()函数去掉串左边的空格，Trim()函数去掉串左右两边的空格；3.AS(alias)关键字，为字段赋予别名。 第十一章 使用数据处理函数mysql&gt; SELECT vend_name,Upper(vend_name) AS vend_name_upcase -&gt; FROM vendors -&gt; ORDER BY vend_name; +----------------+------------------+ | vend_name | vend_name_upcase | +----------------+------------------+ | ACME | ACME | | Anvils R Us| ANVILS R US | | Furball Inc. | FURBALL INC. | | Jet Set| JET SET | | Jouets Et Ours | JOUETS ET OURS | | LT Supplies| LT SUPPLIES | +----------------+------------------+ //文本处理函数 SELECT cust_id,order_num FROM orders WHERE Date(order_date)=&apos;2005-09-01&apos;; //日期和事件处理函数 //检索order_date为2005-09-01的订单记录 SELECT cust_id,order_num FROM orders WHERE Date(order_date) BETWEEN &apos;2005-09-01&apos; AND &apos;2005-09-30&apos;; // 日期和事件处理函数 // 检索2005年9月下的所有订单 SELECT cust_id,order_num FROM orders WHERE Year(order_date)=2005 AND Month(order_date)=9; // 日期和事件处理函数 // 检索2005年9月下的所有订单 Tips： 1.三种数据处理函数：文本处理、日期和时间处理、数值处理。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty通信组件]]></title>
    <url>%2Fblog%2F2016%2F07%2F30%2FNetty%E9%80%9A%E4%BF%A1%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[netty是一套在java NIO的基础上封装的便于用户开发网络应用程序的api. 应用场景很多,诸如阿里的消息队列(RocketMQ),分布式rpc(Dubbo)通信层都使用到了netty(dubbo可以用服务发现自由选择通信层). 主要优点个人总结如下: 1.netty是非阻塞事件驱动框架, 并结合线程组(group)的概念,可以很好的支持高并发,慢连接的场景。 2.编程接口非常容易,并且也较好的解决了TCP粘包/拆包的问题.netty提供了自己的ByteBuf和channel,相比于jdk的ByteBuffer和channel来说更简便灵活操作, 并提供了pipeline的概念,并针对每个contextHandler都可以由用户定义, 方便直接。 3.有一些web框架已经开始直接使用netty做为底层通信服务,诸如play. 这样play就不用依赖于容器去进行部署,在没有nginx做反向代理的情况下也能支持高并发.编解码器可以随意扩展,今天是个web，明天就可以是一个ftp或email服务器,个人觉得比较灵活。 4.传统Blocking IO，每请求每线程。IO线程作为生产者，串行接受请求，不断向队列中发送消息（任务），线程池作为消费者，从队列中接收消息（任务），分配给工作线程处理（执行）。而每个请求都离不开IO的读写阻塞，这也直接导致工作线程跟着阻塞。 5.新Netty采用的New IO，同样是每请求每线程。同样也是IO线程作为生产者，线程池作为消费者。唯一的区别是，相对BIO，每线程的服务时间缩短了。因为在队列和消费者中间，插入一个轮询线程Selector，它会不断去询问每个请求，是否读写操作准备就绪，只有操作就绪，才开启工作线程，从而减少了单个线程的无谓等待时间，提高工作线程的整体执行效率。 6.NIO的全称是NoneBlocking IO，非阻塞IO，区别与BIO，BIO的全称是Blocking IO，阻塞IO。那这个阻塞是什么意思呢？Accept是阻塞的，只有新连接来了，Accept才会返回，主线程才能继 Read是阻塞的，只有请求消息来了，Read才能返回，子线程才能继续处理 Write是阻塞的，只有客户端把消息收了，Write才能返回，子线程才能继续读取下一个请求所以传统的多线程服务器是BlockingIO模式的，从头到尾所有的线程都是阻塞的。这些线程就干等在哪里，占用了操作系统的调度资源，什么事也不干，是浪费。 那么NIO是怎么做到非阻塞的呢。它用的是事件机制。它可以用一个线程把Accept，读写操作，请求处理的逻辑全干了。如果什么事都没得做，它也不会死循环，它会将线程休眠起来，直到下一个事件来了再继续干活，这样的一个线程称之为NIO线程。 while true { events = takeEvents(fds) // 获取事件，如果没有事件，线程就休眠 for event in events { if event.isAcceptable { doAccept() // 新链接来了 } elif event.isReadable { request = doRead() // 读消息 if request.isComplete() { doProcess() } } elif event.isWriteable { doWrite() // 写消息 } } } NIO的流程大致就是上面的伪代码描述的过程，跟实际真实的代码有较多差异，不过对于初学者，这样理解也是足够了。 Netty是建立在NIO基础之上，Netty在NIO之上又提供了更高层次的抽象。在Netty里面，Accept连接可以使用单独的线程池去处理，读写操作又是另外的线程池来处理。 Accept连接和读写操作也可以使用同一个线程池来进行处理。而请求处理逻辑既可以使用单独的线程池进行处理，也可以跟放在读写线程一块处理。线程池中的每一个线程都是NIO线程。用户可以根据实际情况进行组装，构造出满足系统需求的并发模型。Netty提供了内置的常用编解码器，包括行编解码器［一行一个请求］，前缀长度编解码器［前N个字节定义请求的字节长度］，可重放解码器［记录半包消息的状态］，HTTP编解码器，WebSocket消息编解码器等等 Netty提供了一些列生命周期回调接口，当一个完整的请求到达时，当一个连接关闭时，当一个连接建立时，用户都会收到回调事件，然后进行逻辑处理。 Netty可以同时管理多个端口，可以使用NIO客户端模型，这些对于RPC服务是很有必要的。 Netty除了可以处理TCP Socket之外，还可以处理UDP Socket。 在消息读写过程中，需要大量使用ByteBuffer，Netty对ByteBuffer在性能和使用的便捷性上都进行了优化和抽象。 总之，Netty是Java程序员进阶的必备神奇。如果你知其然，还想知其所以然，一定要好好研究下Netty。如果你觉得Java枯燥无谓，Netty则是重新开启你对Java兴趣大门的钥匙。]]></content>
      <categories>
        <category>读者</category>
      </categories>
      <tags>
        <tag>读者</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一名合格的架构师]]></title>
    <url>%2Fblog%2F2015%2F07%2F30%2F%E6%80%8E%E4%B9%88%E6%88%90%E4%B8%BA%E6%9E%B6%E6%9E%84%E5%B8%88%2F</url>
    <content type="text"><![CDATA[怎样学习才能从一名Java初级程序员成长为一名合格的架构师，或者说一名合格的架构师应该有怎样的技术知识体系，这是不仅一个刚刚踏入职场的初级程序员也是工作三五年之后开始迷茫的老程序员经常会问到的问题。希望这篇文章会是你看到过的最全面最权威的回答。 一： 编程基础不管是C还是C++，不管是Java还是PHP，想成为一名合格的程序员，基本的数据结构和算法基础还是要有的。下面几篇文章从思想到实现，为你梳理出常用的数据结构和经典算法。 1-1 常用数据结构数组、链表、堆、栈、队列、Hash表、二叉树等 1-2 算法思想算法时间复杂度和空间复杂度的分析计算 算法思想：递推、递归、穷举、贪心、分治、动态规划、迭代、分枝界限 1-3 经典算法经典排序：插入排序、冒泡排序、快排（分划交换排序）、直接选择排序、堆排序、合并排序 经典查找：顺序查找、二分查找、二叉排序树查找 1-4 高级数据结构B+/B-数、红黑树、图等 1-5 高级算法图的深度优先搜索、图的广度优先搜索、拓扑排序、Dijkstra算法（单源最短路径）、霍夫曼编码、辗转相除法、最小生成树等 二：Java语言基础诞生不过二十余年的Java语言凭借其跨平台、面向对象、适合于分布式计算的特性，广泛应用于Web网站、移动设备、桌面应用中，并且已经连续多年稳居TOBIE编程语言排行榜前列，最近更是登上冠军宝座。Java有哪些优秀而又与众不同的地方首先一定要清楚。 2-1 基础语法Java语法格式，常量和变量，变量的作用域，方法和方法的重载，运算符，程序流程控制，各种基本数据类型及包装类 2-2 重要：集合类Collection以及各种List、Set、Queue、Map的实现以及集成关系，实现原理 Collections和Arrays 2-3 其他JavaAPIString和StringBuffer，System和Runtime类，Date和DateFomat类 java.lang包 java.util包（集合类体系、规则表达式、zip，以及时间、随机数、属性、资源和Timer等） java.math包 java.net包 java.text包（各种格式化类等） java.security包 2-4 面向对象、面向接口对象的三大特性：封装、继承和多态，优缺点 如何设计类，类的设计原则 this关键字，final关键字，static关键字 对象的实例化过程 方法的重写和重载；方法和方法的参数传递过程 构造函数 内部类，抽象类，接口 对象的多态性（子类和父类之间的转换、父类纸箱子类的引用），抽象类和接口在多态中的应用 2-5 JVM内存模型、垃圾回收2-6 关于异常Throwable/Error/Exception，Checked Exception vs. Unchecked Exception，异常的捕捉和抛出，异常捕捉的原则，finally的使用 2-7 多线程线程和进程的概念 如何在程序中创建多线程，线程安全问题，线程之间的通讯 线程的同步 死锁问题的剖析 线程池 2-8 IOjava.io包，理解IO体系的基于管道模型的设计思路以及常用IO类的特性和使用场合。 File及相关类，字节流InputStream和OutputStream，字符流Reader和Writer，以及相应缓冲流和管道流，字节和字符的转化流，包装流，以及常用包装类使用 分析IO性能 2-9XML熟悉SAX、DOM以及JDOM的优缺点并且能够使用其中的一种完成XML的解析及内容处理；这几种解析方法的原理 2-10 一些高级特性反射、代理、泛型、枚举、Java正则表达式 2-11 网络编程网络通信协议原理及适用场景，Socket编程，WEB服务器的工作原理 2-11 JDK1.5、JDK1.6、JDK1.7、JDK1.8每个版本都比前面一个版本添加了哪些新特性，进行了哪些提升 三：数据库相关前面说到了数据结构，数据库简单来说就像是电子化的档案柜，是按照一定的数据结构来组织、存储和管理数据的仓库。 3-1理论基础数据库设计原则和范式 事务（ACID、工作原理、事务的隔离级别、锁、事务的传播机制） 3-2 各种数据库优缺点、使用场景分析MySQL/SQLServer/Oracle以及各种NoSQL(Redis、MongoDB、Memcached、HBase、CouchDB等) 3-2 SQL语句数据库创建，权限分配，表的创建，增删改查，连接，子查询 触发器、存储过程、事务控制 3-3 优化索引原理及适用，大表查询优化，多表连接查询优化，子查询优化等 3-4 分库、分表、备份、迁移导入、导出，分库、分表，冷备热备，主从备份、双机热备、纵向扩展、横向扩展 3-5 JDBCJDBC Connection、Statement、PreparedStatement、CallableStatement、ResultSet等不同类的使用 连接池（配置使用、实现原理） ORM，DAO 四：JavaWeb核心技术（包括部分前端）Html5/Css/JS原生/jQuery Ajax（跨域等） JSP/JavaBean/Servlet/EL/JSTL/TabLib JSF JSON EJB 序列化和反序列化 规则引擎 搜索引擎 模板引擎 缓存 身份认证 测试 集群 持久化 生成静态页技术 高性能 安全 事务JTA 其他需要了解的，如：管理JMX、安全JCCA/JAAS、集成JCA、通信JNDI/JMS/JavaMain/JAF、SSI技术 五、主流框架及工具Struts1/Struts2 Spring（IoC、AOP等），SpringMVC 持久化：Hibernate/MyBatis 日志：Log4j 单元测试：JUnit 消息队列：ActiveMQ、RabbitMQ等 负载均衡：Nginx/HaProxy Web服务器：Tomcat、JBoss、Jetty、Resin、WebLogic、WebSphere等 通信：WebService(cxf的soap、restful协议) 缓存：Redis、Memcached 工作流：Activity、JBPM 搜索引擎：lucene，基于lucene封装的solr 模板引擎：Velocity、FreeMaker 大数据：Hadoop（HDFS和MapReduce） 构建工具：Ant/Maven 六、JavaWeb系统设计与架构Java设计模式 JAVA与UML建模 面向服务架构：SOA/SCA/ESB/OSGI/EAI，微服务 面向资源架构：ROA/REST 面向云架构：COA/Saas/云计算 大型网站负载均衡、系统调优等 七、More排错能力： 应该可以根据异常信息比较快速的定位问题的原因和大致位置 优化能力 代码规范、代码管理： 有自己的代码规范体系，代码可读性好 知识面广： 懂各种网络产品及特性，懂各种中间件，能够知道坑在哪儿，深谙各种技术方案的优缺点，懂整合各种资源并达到最优….了解各种技术及应用场景，有足够的工作经验解决集成中遇到的各种奇葩问题 技术管理/技术总监： 产品管理、项目管理、团队建设、团队提升 CTO： 发展战略]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
